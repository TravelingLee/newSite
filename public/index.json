


[{"content":"","date":"2026年01月06日","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2026年01月06日","externalUrl":null,"permalink":"/","section":"Limou's Site","summary":"","title":"Limou's Site","type":"page"},{"content":"","date":"2026年01月06日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2026年01月06日","externalUrl":null,"permalink":"/tutorial/","section":"Tutorials","summary":"","title":"Tutorials","type":"tutorial"},{"content":"","date":"2026年01月06日","externalUrl":null,"permalink":"/categories/%E5%89%8D%E7%AB%AF/","section":"Categories","summary":"","title":"前端","type":"categories"},{"content":"","date":"2026年01月06日","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%AB%AF/","section":"Tags","summary":"","title":"前端","type":"tags"},{"content":" 事情起因 # 最近使用必应搜索技术类关键词，经常出现一个垃圾网站，名为“云原生实践”，域名oryoy.com，这网站不仅经常出现，还占据大量篇幅，有时候10条搜索结果中可能有5条是这个网站。 # 可以看到一页搜索结果就有三个这个网站 直到有一天我确实感觉很烦，而且这网站的内容一看就是用比较差的AI生成的，通篇垃圾，没有什么参考价值，于是我打开了它的网站主页，不看不知道，一看吓一跳，好家伙 一页有多少篇文章我都不想数了，实在太多，于是我打开了控制台 可以看到一页是100篇文章，通过改变query参数看了一下页数，截止到当天下午4点，当天发布的文章已经达到了301页，也就是3万多篇，照这个节奏，这个网站一天就能生成4万~5万篇垃圾文章，并且通过疯狂的SEO推向Bing，严重污染搜索引擎。 除了Bing以外，我发现被污染的搜索引擎还有DuckDuckGo，但没有Bing那么严重，而百度和Google暂未发现被污染，也许是网站运营者没有去提交，亦可能是搜索引擎收录机制的差异。总之，此类网站的出现真是AI和搜索引擎的一大悲哀啊，太影响使用体验了。 动手解决 # 于是我尝试寻找可以屏蔽搜索引擎搜索结果的插件或者油猴脚本，但发现没有什么兼容性比较好的选择，总有漏网之鱼，最后只能自己编写了。 脚本很简单,代码行数不多,寻找页面特征元素并编写合适的选择器才是关键。然而未来搜索引擎网页结构可能改变，这些可能也就失效了，不过呢，我也会时常更新的，敬请关注。\n代码 # // ==UserScript== // @name search shielder // @namespace http://tampermonkey.net/ // @version 2026-01-06 // @description try to take over the world! // @author Limou // @match *://*.bing.com/* // @match *://bing.com/* // @match *://duckduckgo.com/* // @match *://*.duckduckgo.com/* // @match *://baidu.com/* // @match *://*.baidu.com/* // @match *://google.com/* // @match *://*.google.com/* // @icon https://www.google.com/s2/favicons?sz=64\u0026amp;domain=mozilla.org // @grant none // ==/UserScript== // this script was used to block search results from oryoy.com in Bing and DuckDuckGo, // and now I only find these two search engines contaminated by it (function() { \u0026#39;use strict\u0026#39;; // Your code here... // 屏蔽列表，可自行添加 const shieldingURLs = [ \u0026#39;oryoy.com\u0026#39;, \u0026#39;githubup.com\u0026#39;, \u0026#39;githubrsp.com\u0026#39; ] // 当前地址路径 const currentLocation = window.location.href // 预编译正则匹配 const isBing = /\\S*:\\/\\/\\S*bing.com\\/\\S*/.test(currentLocation) const isDuckDuckGo = /\\S*:\\/\\/\\S*duckduckgo.com\\/\\S*/.test(currentLocation) const isBaidu = /\\S*:\\/\\/\\S*baidu.com\\/\\S*/.test(currentLocation) const isGoogle = /\\S*:\\/\\/\\S*google.com\\/\\S*/.test(currentLocation) // 是否已经存在 SPA 监听器 let existSPAListener = false // 入口函数 function start() { SPAListener() // 针对 Bing 的屏蔽匹配 if (isBing) { console.log(\u0026#39;Bing DOM变化\u0026#39;) debounce(shieldBing(), 1000)() } // 针对 DuckDuckGo 的屏蔽匹配 else if (isDuckDuckGo) { console.log(\u0026#39;Duck DOM变化\u0026#39;) debounce(shieldDuckDuckGo(), 1000)() } else if (isBaidu) { console.log(`百度DOM变化`); debounce(shieldBaidu(), 1000)() } else if (isGoogle) { console.log(`Google DOM 变化`); debounce(shieldGoogle(), 1000)() } } // 获取 Google 的结果 item 容器 function getItemParentNode(node) { for (let i = 0; i \u0026lt; 12; i++) { node = node.parentNode } return node.parentNode.getAttribute(\u0026#39;id\u0026#39;) === \u0026#39;rso\u0026#39; ? node : node.parentNode } // 屏蔽 Google 搜索结果 function shieldGoogle() { const googleWaitToRemoves = [] const nodes = document.querySelectorAll(\u0026#39;cite\u0026#39;) nodes.forEach(node =\u0026gt; { const domain = node.innerText console.log(node) if (shieldingURLs.some(url =\u0026gt; domain.includes(url))) { const itemContainer = getItemParentNode(node) // 先隐藏，并加入数组 itemContainer.setAttribute(\u0026#39;style\u0026#39;, \u0026#39;display: none\u0026#39;) googleWaitToRemoves.push(itemContainer) } }) // 批量删除，防止阻塞DOM渲染 removeElementsBatch(googleWaitToRemoves, 0) } // 屏蔽 DuckDuckGo 搜索结果 function shieldDuckDuckGo() { const ddgWaitToRemoves = [] const nodes = document.getElementsByClassName(\u0026#39;react-results--main\u0026#39;)[0].querySelectorAll(\u0026#34;li[data-layout=\u0026#39;organic\u0026#39;]\u0026#34;) console.log(nodes); for (const node of nodes) { const href = node.querySelector(\u0026#39;article \u0026gt; div \u0026gt; div \u0026gt; div \u0026gt; a\u0026#39;).getAttribute(\u0026#39;href\u0026#39;) if ((href \u0026amp;\u0026amp; shieldingURLs.some(url =\u0026gt; href.includes(url)))) { let li = queryBingLi(node) if (li) { li.setAttribute(\u0026#39;style\u0026#39;, \u0026#39;display: none\u0026#39;) ddgWaitToRemoves.push(li) } } } removeElementsBatch(ddgWaitToRemoves, 0) } // 屏蔽 Bing 搜索结果 function shieldBing() { const bingWaitToRemoves = [] // 从一般搜索结果中去除 const nodes = document.querySelectorAll(\u0026#39;#b_results .b_algo\u0026#39;) for (const node of nodes) { const ariaLabel = node.querySelector(\u0026#39;a\u0026#39;).getAttribute(\u0026#39;aria-label\u0026#39;) const href = node.querySelector(\u0026#39;a\u0026#39;).getAttribute(\u0026#39;href\u0026#39;) if ((ariaLabel \u0026amp;\u0026amp; shieldingURLs.some(url =\u0026gt; ariaLabel.includes(url))) || (href \u0026amp;\u0026amp; shieldingURLs.some(url =\u0026gt; href.includes(url)))) { let li = queryBingLi(node) if (li) { li.setAttribute(\u0026#39;style\u0026#39;, \u0026#39;display: none\u0026#39;) bingWaitToRemoves.push(li) } } } // 从 bing 结果页顶部内容中去除 const headerDivs = document.getElementsByClassName(\u0026#39;gs_cits\u0026#39;)[0]?.querySelectorAll(\u0026#39;.gs_cit\u0026#39;) if (headerDivs) headerDivs.forEach(headerDiv =\u0026gt; { const dataUrl = headerDiv.getAttribute(\u0026#39;data-url\u0026#39;) if (shieldingURLs.some(url =\u0026gt; dataUrl.includes(url))) { headerDiv.setAttribute(\u0026#39;style\u0026#39;, \u0026#39;display: none\u0026#39;) bingWaitToRemoves.push(headerDiv) } }) removeElementsBatch(bingWaitToRemoves, 0) } // 触发 history push 时，同时会触发 spaNavigation function SPAListener() { const pushState = history.pushState history.pushState = function (state, title, url) { // 插入一个事件监听器 window.dispatchEvent(new CustomEvent(\u0026#39;spaNavigation\u0026#39;, { detail: { url, type: \u0026#39;push\u0026#39; } })) // 让原函数正常运行 return pushState.apply(this, arguments) } if (!existSPAListener) window.addEventListener(\u0026#39;spaNavigation\u0026#39;, (e) =\u0026gt; { console.log(\u0026#39;监听到路由变化\u0026#39;) if (isBaidu) { debounce(shieldBaidu(), 500)() } else if (isDuckDuckGo) { debounce(shieldDuckDuckGo(), 500)() } }) } // 百度去广告 function shieldBaidu() { const baiduWaitToRemoves = [] // 一般屏蔽 const resultList = document.querySelectorAll(\u0026#39;#content_left \u0026gt; div\u0026#39;) if (resultList) resultList.forEach(result =\u0026gt; { const mu = result.getAttribute(\u0026#39;mu\u0026#39;) if (mu \u0026amp;\u0026amp; shieldingURLs.some(url =\u0026gt; mu.includes(url))) { result.setAttribute(\u0026#39;style\u0026#39;, \u0026#39;display: none\u0026#39;) baiduWaitToRemoves.push(result) } }) // 去除一般广告 const adsNodes = document.querySelectorAll(\u0026#34;div[prank=\u0026#39;1\u0026#39;], div[prank=\u0026#39;2\u0026#39;], div[prank=\u0026#39;3\u0026#39;], div[prank=\u0026#39;4\u0026#39;]\u0026#34;) if (adsNodes) adsNodes.forEach(node =\u0026gt; { node.setAttribute(\u0026#39;style\u0026#39;, \u0026#39;display: none\u0026#39;) baiduWaitToRemoves.push(node) }) // 去除品牌广告 const topAdsNode = document.querySelector(\u0026#39;.tenon_pc_comp_content_container.c-border\u0026#39;) if (topAdsNode) { topAdsNode.parentNode.setAttribute(\u0026#39;style\u0026#39;, \u0026#39;display: none\u0026#39;) baiduWaitToRemoves.push(topAdsNode.parentNode) } // 去除底部广告 const bottomAdNodes = document.querySelectorAll(\u0026#39;.result.c-container.new-pmd a\u0026#39;) console.log(\u0026#39;所有\u0026#39;, bottomAdNodes) if (bottomAdNodes) bottomAdNodes.forEach(node =\u0026gt; { const isAds = node.innerText === \u0026#39;广告\u0026#39; if (isAds) { node.parentNode.parentNode.setAttribute(\u0026#39;style\u0026#39;, \u0026#39;display: none\u0026#39;) baiduWaitToRemoves.push(node.parentNode.parentNode) } }) removeElementsBatch(baiduWaitToRemoves, 0) } // Bing 从特征节点向外查找父级 li 元素 function queryBingLi(node) { while (node \u0026amp;\u0026amp; node.nodeName !== \u0026#39;LI\u0026#39;) { node = node.parentNode if (!node || node.nodeName === \u0026#39;HTML\u0026#39;) return null } return node } // 批量删除节点 function removeElementsBatch(elements, timeout) { setTimeout(() =\u0026gt; { elements.forEach(el =\u0026gt; { if (el \u0026amp;\u0026amp; el.parentNode) { el.parentNode.removeChild(el) } }, timeout) }) } function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () =\u0026gt; { clearTimeout(timeout); func.apply(this, args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }.bind(this); } let isProcessing = false const observer = new MutationObserver(mutations =\u0026gt; { if (isProcessing) return isProcessing = true // 防抖，防止 DOM 频繁变化导致频繁调用 setTimeout(() =\u0026gt; { start() isProcessing = false }, 100); }) observer.observe(document.body, { childList: true, subtree: true }) })(); 安装使用 # 以Firefox为例，点击右上角的模块图标 进入浏览器扩展管理页面，搜索tampermonkey，安装扩展，并将扩展固定到工具栏 tampermonkey安装后其扩展名称为“篡改猴” 点击工具栏中的tampermonkey图标，选择添加新脚本 清空其中原有的内容，复制并粘贴以上代码，Ctrl+S或者点文件——\u0026gt;保存。 完成 接下来来到Google/Bing/百度/DuckDuckGo任意搜索引擎页面，点击右上角的篡改猴扩展图标，search shielder就是刚才添加的脚本，我们需要点击左边的开关启用这个脚本 下面是屏蔽前后效果演示 脚本在Ubuntu系统的Firefox、Zen Browser和Edge上测试基本上没有什么问题，其它的未测试。\n手机端也能用，但由于页面结构可能有细微不同，效果可能会有些许不同。支持脚本的手机浏览器：Firefox、Edge、Via、X浏览器。\n","date":"2026年01月06日","externalUrl":null,"permalink":"/tutorial/2026/01/post-shield-script/","section":"Tutorials","summary":"事情起因 # 最近使用必应搜索技术类关键词，经常出现一个垃圾网站，名为“云原生实践”，域名oryoy.com，这网站不仅经常出现，还占据大量篇幅，有时候10条搜索结果中可能有5条是这个网站。 # ","title":"写个脚本屏蔽搜索引擎中的垃圾网站oryoy.com","type":"tutorial"},{"content":"","date":"2022年06月25日","externalUrl":null,"permalink":"/categories/android%E5%BC%80%E5%8F%91/","section":"Categories","summary":"","title":"Android开发","type":"categories"},{"content":"","date":"2022年06月25日","externalUrl":null,"permalink":"/tags/android%E5%BC%80%E5%8F%91/","section":"Tags","summary":"","title":"Android开发","type":"tags"},{"content":" 解决genymotion虚拟机无法启动的问题 # 解法一 # genymotion是依赖于virtualbox的\n打开virtualbox\n点击你的genymotion对应的那个虚拟机\n查看右边网络那一栏对应的网络适配器\n右键点击电脑右下角的网络图标，打开网络与共享中心（打开“网络和Internet”设置）\n更改适配器选项\n在网络适配器上悬停鼠标，查看哪个是你的virtualbox那边对应的适配器\n查看此适配器是否是打开状态（由于某些bug，有时候显示“已禁用”的适配器实际上是打开状态。要右键此适配器，如果显示启动，那么就是关闭状态，否则就是打开状态。），如果未打开，打开即可。 注意，启动的过程中可能会疯狂请求管理员权限，请同意\n解法二 # 如果解法一不奏效，可能会是genymotion和virtualbox的兼容性问题，那就解法二了\n去genymotion官网下载genymotion with virtualbox，如图，下面那个便是 安装好之后可能会提示找不到virtualbox，那可能是你的电脑安全软件拦截了，因为安装virtualbox的时候会请求管理员权限，安装genymotion的过程中会同步安装virtualbox，如果被拦截了就会安装不上，要注意查看安全软件的提示，或者直接把安全软件关掉 上面就绪之后，去genymotion里面安装一个你需要的虚拟机，然后启动，仍然启动失败，提示“找不到网卡\u0026hellip;\u0026hellip;”或者“找不到适配器\u0026hellip;\u0026hellip;”之类的有关网络的提示 按照解法一的步骤打开适配器即可 ","date":"2022年06月25日","externalUrl":null,"permalink":"/tutorial/2022/06/tutorial-genymotion-boot/","section":"Tutorials","summary":"解决genymotion虚拟机无法启动的问题","title":"解决genymotion虚拟机无法启动的问题","type":"tutorial"},{"content":"","date":"2022年06月25日","externalUrl":null,"permalink":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/","section":"Tags","summary":"","title":"虚拟机","type":"tags"},{"content":"根据目前（2022-05-12）最新的APlayer和MetingJS进行编写的，示例来自MetingJS的GitHub项目，项目地址：https://github.com/metowolf/MetingJS/tree/master 在博客园后台的页脚代码中添加如下代码：\n\u0026lt;!-- require APlayer --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- require MetingJS --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;meting-js server=\u0026#34;netease\u0026#34; type=\u0026#34;playlist\u0026#34; mini=\u0026#34;true\u0026#34; fixed=\u0026#34;true\u0026#34; id=\u0026#34;2846803618\u0026#34;\u0026gt; \u0026lt;/meting-js\u0026gt; 这里是引用网易云的歌单，server就是指定音乐平台；这里的id是网易云歌单id，你可以换成你自己喜欢的歌单。除了歌单，你也可以添加单首歌，改变type属性的参数即可。 关于MetingJS的属性，请访问MetingJS的GitHub页面，参考官方文档。\n","date":"2022年05月12日","externalUrl":null,"permalink":"/tutorial/2022/05/tutorial-musicplayer-cnblog/","section":"Tutorials","summary":"根据目前（2022-05-12）最新的APlayer和MetingJS进行编写的，示例来自MetingJS的GitHub项目","title":"博客园底部添加音乐播放器","type":"tutorial"},{"content":"","date":"2022年05月12日","externalUrl":null,"permalink":"/tags/%E5%BB%BA%E7%AB%99/","section":"Tags","summary":"","title":"建站","type":"tags"},{"content":" 哪些数据适合做可视化 # 我们在运营自己的网站的时候，很多时候我们希望能够掌握自己网站的数据，包括网站的访客数量、网站中个分类的文章数量、各个月份的文章数量等。而且很多时候我们不希望我们拿到的是冷冰冰的数据，而是一目了然的数据。这时候数据可视化就非常有用了，如果我们能够通过图表来让自己的网站的数据一目了然，岂不美哉？\n数据可视化工具介绍 # 现在网络上的前端图表库其实并不少，并且很多都是开源的，也就是说，你可以直接拿来用，而不需要付费。其中最有名气的当属由百度主导的echarts项目，现在该项目已经在Apache开源基金会孵化中。echarts是一个非常好用的图表库，不需要什么前置技能，只需要懂一点点JavaScript和json语法即可使用。echarts的图表数据使用json进行渲染。\n如下代码就是echarts官网给出的一个简单的图表对象实例： option = { series: [ { type: \u0026#39;pie\u0026#39;, data: [ { value: 335, name: \u0026#39;直接访问\u0026#39; }, { value: 234, name: \u0026#39;联盟广告\u0026#39; }, { value: 1548, name: \u0026#39;搜索引擎\u0026#39; } ] } ] }; 上述代码中的option是对象的名字，对象中包含的series数组就是用于配置该图表的数据，其中的type字段用于确定图表的类型，pie表示类型为饼图，data数据就是饼图的各个块的数据，value表示该块的数值，name是该块的名字，更多关于echarts对象的API可以参考echarts的官方文档：Documentation - Apache ECharts\n一个完整的实例，可直接写到HTML中用浏览器打开即可看到效果： \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34; style=\u0026#34;width: 600px;height: 400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var myChart = echarts.init(document.getElementById(\u0026#39;root\u0026#39;)) option = { series: [ { type: \u0026#39;pie\u0026#39;, data: [ { value: 335, name: \u0026#39;直接访问\u0026#39; }, { value: 234, name: \u0026#39;联盟广告\u0026#39; }, { value: 1548, name: \u0026#39;搜索引擎\u0026#39; } ] } ] }; myChart.setOption(option) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 完整实例的讲解 要让图表显示出来，那就需要一个容器来放置图表。上述代码中的\n\u0026lt;div id=\u0026#34;root\u0026#34; style=\u0026#34;width: 600px;height: 400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 就是用来放置图表的容器，这里需要注意，一定要给容器设置宽高，因为图表都是有一定的宽度和高度的，如果不设置宽高，将会导致图表显示不出来。\n脚本中的以下这句\nvar myChart = echarts.init(document.getElementById(\u0026#39;root\u0026#39;)) 是根据id获取到div标签，然后用这个标签作为容器来初始化echarts图表。\n以下这句是把图表放置到容器中\nvar myChart.setOption(option) 完整实例的效果展示 zblog API介绍 # zblog是有官方文档的，可以去官方文档中去查看相关的API：接口文档 - API (zblogcn.com)\n这里我们只用到一个API即可： 请求格式：https://example.com/zb_system/api.php?mod=category\u0026amp;act=list，把example.com换成你自己的域名即可。\n请求之后会返回json格式的数据，类似这样的： 然后我们复制这些文本，打开网站json.cn，解析一下json数据，查看json的结构，以便进行json解析。\n可以看到，这个json对象中有一个data对象，data对象中又有一个list数组，这个数组列出了网站的所有分类的ID和分类名称，以及分类下的文章数量等：\n那么我们可以想想我们需要哪些数据呢？很显然，我们只需要分类名称和该分类下的文章数量即可构建一个饼图。\n而echarts图表的配置项实际上也是一个json对象，所以这就很简单了。\n思路如下\n我们只需要在我们的网站的页面加载时，请求API获取文章分类数据，然后把返回的json字符串转换成json对象（只有json对象才能解析），然后把解析出来的只赋值给option对象的相应值即可。\n把文章统计图表做成zblog模块 # 打开zblog后台页面 zblogphp：https://example.com/zb_system/admin/index.php\n点击网站设置-\u0026gt;API设置-\u0026gt;启用API协议 点击模块管理，再点击新建模块，然后复制以下代码到zblog“正文”的编辑框里面（把代码中的example.com换成你自己的网站域名），名称、文件名、HTML ID自己随便填，类型选择div，其它不管，提交即可。 模块代码\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;div id=\u0026#34;statistics\u0026#34; style=\u0026#34;display:flex;flex-direction:row;justify-content:center;width:280px;height:375px\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var chartDom = document.getElementById(\u0026#39;statistics\u0026#39;); var myChart = echarts.init(chartDom); var option; option = { title: {//图表的标题配置项 text: \u0026#39;各分类文章数量\u0026#39;,//图表标题 left: \u0026#39;center\u0026#39;//图表左右位置 }, tooltip: {//提示框 trigger: \u0026#39;item\u0026#39;//item表示在饼块上触发提示框显示 }, legend: {//图例的配置项 // orient: \u0026#39;vertical\u0026#39;, left: \u0026#39;center\u0026#39;,//图例左右位置 bottom: \u0026#39;0\u0026#39;//图例上下位置 }, series: [//“饼”的配置项 { // name: \u0026#39;\u0026#39;, top:\u0026#39;-20%\u0026#39;,//饼图到顶部的距离 // left: \u0026#39;center\u0026#39;, type: \u0026#39;pie\u0026#39;,//pie表示饼图 stillShowZeroSum: false,//数据值总数为零时是否显示饼图 radius: \u0026#39;50%\u0026#39;,//饼图半径 data: [//饼图的各个块的名字和数值，可以根据需要动态地push。 //因为分类数量不是经常变化的，所以也可以像这样一个个地写死 { value: null, name: null }, { value: null, name: null }, { value: null, name: null }, { value: null, name: null }, { value: null, name: null }, { value: null, name: null }, { value: null, name: null }, { value: null, name: null }, { value: null, name: null }, { value: null, name: null }, ], emphasis: { itemStyle: {//这是设置样式的，相关API可以去查看官方文档 shadowBlur: 10, shadowOffsetX: 0, shadowColor: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39; } } } ] }; function setData() {//发送和处理zblog API的函数 const Http = new XMLHttpRequest() //把下面的example.com改成你的网站域名，其它的，包括上面的都不用改 //这里全部代码只改这一处即可，这是最简单的方法了，而且效果还挺好的，改好域名直接保存用浏览器访问 const url = \u0026#39;https://example.com/zb_system/api.php?mod=category\u0026amp;act=list\u0026#39; Http.open(\u0026#39;GET\u0026#39;,url) Http.send() Http.onreadystatechange=function(){ if (this.readyState == 4 \u0026amp;\u0026amp; this.status==200){ var JSONObject = JSON.parse(Http.responseText) for (var i = 0; i \u0026lt; JSONObject.data.list.length; i++) { option.series[0].data[i].value = parseInt(JSONObject.data.list[i].Count) option.series[0].data[i].name = JSONObject.data.list[i].Name } myChart.setOption(option) } } } window.onload = setData myChart.on(\u0026#39;click\u0026#39;,function(params){ var cateId = params.dataIndex+2 window.location.href = \u0026#39;https://\u0026#39;+window.location.host+\u0026#39;/category-\u0026#39;+cateId+\u0026#39;.html\u0026#39; // console.log(window.location.host+\u0026#39;?cate=\u0026#39;+cateId) }) option \u0026amp;\u0026amp; myChart.setOption(option); \u0026lt;/script\u0026gt; 解决一些问题 # echarts饼图的“饼块”是可以添加点击事件的，一开始我使用动态网页的时候，这些点击事件没有任何问题，可以正常点击，但是当我开启了伪静态之后，就开始出现404了，因为地址重写出错。开始的时候跳转是通过cate=id的参数来跳转的，但是伪静态之后，cate变成了category-id.html，因为zblog的静态管理中心的伪静态规则是这样的，那既然这样，我就直接把点击事件的跳转地址改成category-id.html即可。（这个问题在模块代码中已经解决了） 分类页面切换排序出现404，分类页面点击 当前位置：首页 \u0026gt; 分类名称 里的分类名称时404。这个问题其实也是伪静态URL重写出了问题，我们在访问分类页面的时候访问的是带参数cate=id的URL，例如：例如：https://www.example.com/?cate=4，但是当我们切换排序的时候，URL被重写成：https://www.example.com/?order=newlist\u0026amp;sort=0，分类参数丢失导致404。其实也是cate=id参数变成了category-id。这个问题通过上面第一种情况的设置可以解决。 从顶部分类访问分类页面，点击侧栏的最近发表出现404。这个问题也是URL重写的问题，很简单： 打开zblog后台页面，选择分类管理 点击导航管理 把各个分类的连接改成诸如：https://www.example.com/category-2.html的格式 点击标签404，我本人使用静态规则：{%host%}tags-{%id%}{%page%}.html，出现过404，页出现过id参数乱码，后来经过验证，发现是CDN缓存中的内容版本不是最新的所导致的，把{%host%}tags-{%alias%}{%page%}.html这个规则中的alias别名参数解析到了上面那个规则的id参数的地方导致出错404. ","date":"2022年05月08日","externalUrl":null,"permalink":"/tutorial/2022/05/tutorial-statistical-chart/","section":"Tutorials","summary":"使用前端数据可视化库，结合建站系统的API实现网站统计图，zblog插件商城卖的价格可不便宜，不如自己做","title":"给zblog网站做个统计图","type":"tutorial"},{"content":"","date":"2022年04月27日","externalUrl":null,"permalink":"/tags/cdn/","section":"Tags","summary":"","title":"CDN","type":"tags"},{"content":"最近给我的个人网站开通了CDN服务，折腾了好久才算是“可以用了”，虽然还有一些小小的问题，但好在不是那么地影响使用。其实折腾CDN这回事，我在去年的1月、2月份已经折腾了很久了，当时是第一次去折腾这玩意儿，折腾很久没有个结果，后面不了了之了。但是到了今年，随着学的的东西的增加，有很多东西需要记录，而我又更喜欢一个自己小窝，于是我重新开通了个人网站，并且接入了CDN，重新折腾了一遍。\nCDN是什么 # CDN全称是“内容分发网络”，顾名思义，它就是用来分发内容的网络，就是一层覆盖在原有网络之上的网络层。\nCDN有什么用 # CDN能够提供访问加速功能，还能提供一定的网站防护作用。加速功能就是通过各大云厂商设置在各地的边缘节点，将接入CDN服务的用户的网站的服务器（称为源站）中的内容缓存过来，然后再由各个边缘节点负责所在区域的内容分发工作，从而能够让各个访问网站的用户能够就近获取内容，从而加快访问速度。而网站防护作用就是通过接入CDN，让CDN接管了内容的分发任务，用户访问的是CDN节点的服务器，暴露的是CDN节点的IP地址，而不是用户源站的IP地址，从而降低了用户源站被攻击的风险。\n如何选择CDN提供商 # 如今国内的CDN服务厂家有很多，比如各个大厂：阿里、腾讯、百度，当然还有UCloud、青云、天翼云这些名声没有那么高的，这些厂商的CDN服务质量都差不多，都值得选择。在此要提醒各位的是，选择任何云服务都一定要选择有点名声的那些，不要去选择那些完全不知名的18线厂家（除非你是白嫖的，那就当我没说），因为那些厂家的服务往往没有保障，等你遇到问题的时候无处寻答案，你才会感到绝望。就像这次我给我的网站接入CDN，选择的是腾讯云的CDN，就遇到了不少问题，有些问题是自己难以发现，甚至是不可发现的，但是问客服就能很快找到问题的所在。\n如何为网站接入CDN服务 # 笔者只用过腾讯云和百度智能云的CDN，下面以腾讯云为例介绍接入步骤：\n打开腾讯云官网 # 如图，点击右上角的控制台\n在这里输入图片标题 找到CDN产品 # 如果页面中没有CDN，可以在搜索框中搜索，点击进入。\n点击侧边栏的域名管理 # 进入域名管理页面后，再点击蓝色的添加域名按钮，开始配置源站域名信息。\n配置域名信息 # 域名配置 加速区域：可以根据实际情况选择，不过考虑到个人网站一般都是给国内用户访问而已，所以一般情况下就是选择中国境内即可，如果你的用户群体中有国外用户，那么可以选择“全球”。\n加速域名：就是你为你的网站注册的域名，你想给用户访问的那个网址。（注：建议的域名类型是主域名和www域名。主域名：example.com；www域名：www.example.com)\n加速类型：个人网站选择“网页小文件”即可，上面是普通的CDN，下面是ECDN，普通CDN是可以用流量包抵扣访问流量的，ECDN只能按量付费，而且个人网站需要缓存的只有一些静态的文件，比如图片、小视频，js文件、css文件、HTML文件 ，都是些网页小文件，所以“网页小文件”是最好的选择。\nIPv6访问：可以不用管。\n所属项目：”默认项目“即可。\n源站配置 源站类型：选择自有源。\n回源协议：选择HTTPS。\n源站地址：全部文件填写自己的服务器的IP地址，后面地址和权重不用填。\n回源HOST：在填写加速域名的时候会自动填写，也就是和加速域名一致即可。\n服务配置 此项全部都不用改动，确认提交即可。\n设置CNAME # 配置完毕之后，在域名管理页面点击刚刚已经配置好的域名，然后出现以下界面：\n复制此处的CNAME地址，到你的域名服务商处，添加一个解析记录。\n记录类型：CNAME。 主机记录：如果你加速域名填写的是主域名，此处填写一个**@符号；如果你加速域名填写的是www域名，此处填写www**三个字母。 记录值：上面复制的CNAME地址。 其它不用管，完成添加。 测试CDN # 刷新预热 刚刚接入CDN服务的网站，CDN节点还没有缓存源站的内容，所以不起作用，可以多访问几次就可以访问到CDN节点了。或者可以在CDN控制台选择“刷新预热”。然后选择目录刷新，填写你的源站根目录，比如你设置了两个加速域名：www.example.com和example.com，那么你要刷新预热的目录就是https://www.example.com/和https://example.com/，一行填写一个，提交即可。\n查询IP地址归属 测试的方法是用浏览器直接访问你的加速域名，比如用Chrome浏览器访问，先按F12或者在浏览器窗口中右键选择检查，打开开发者工具，然后再在地址栏输入你的加速域名，回车，可以看到开发者工具中有许多项目或者请求，点击network（网络）项目，可以看到该页面的网络请求，点击任意一个请求，再点击headers（头信息），然后在General中可以看到Remote Address，复制这个IP地址（不包括443端口号），到腾讯云CDN控制台IP归属查询中输入此IP地址即可看到此IP是否属于腾讯云CDN节点IP，如果是，那么说明该请求命中了CDN缓存，如果不是（而是你自己的服务器IP地址）则没有命中。\nx-cache-lookup字段 也可以在headers中找到x-cache-lookup字段，如果显示Hit From Disktank3 Gz，说明命中了CDN节点的硬盘，属于命中了CDN节点的；如果显示Hit From Inner Cluster，说明命中了CDN节点服务器的内存，也是属于命中了CDN节点的；如果显示Cache Miss，说明没有命中CDN节点，而是回源获取内容了。还有一种情况，就是这三种都出现，或者出现大于一种，不用担心，可能是你开启了头信息透传，是可以在CDN控制台关闭的，但是开不开都没必要管它。CDN的原理是，用户访问网站，引导到最近的CDN节点，如果此节点没有所需要的内容，则继续CNAME到该节点周围的其它节点，看看有没有，如果没有，则继续寻找下一个，如果所有节点都没有，就会回源，也就是说CDN寻找内容是递归寻找的。如果开启了头信息透传，那么每一次寻找下一个节点的时候，都会带着头信息过去，就会出现很多次x-cache-lookup。\n接入CDN遇到的问题 # 网页小图标和CSS样式不显示 # 出现这种问题的原因是节点跨域访问的原因，只需要去CDN控制台设置一下跨域访问规则即可。\nCDN控制台-\u0026gt;域名管理-\u0026gt;要配置的域名-\u0026gt;高级配置-\u0026gt;HTTP响应头配置，增加如下规则即可，主要是第三个，其它的可以添加也可以不添加。\naccess-control-allow-origin: *\n首页显示异常，其它页面正常 # 除了首页异常，还有所有页面资源链接也异常，即在开发者工具中看到的请求和资源链接很多都显示了源站IP地址，别忘了我们接入CDN有一个目的就是隐藏自己的源站IP地址，这明显事与愿违了！这可能只是我遇到的问题，因为全网都搜不到答案，最终是靠腾讯云客服解决的。具体是首页只能加载出php渲染的HTML页面，其它任何东西都不显示，包括CSS和图片、图标。我也是和客服对线了很久才找到问题所在，但是我至今不知道为何会出现这样的问题，自从接入CDN以来我从来没有修改过首页的代码，为什么会出现文件版本的差异。客服通过拉取CDN日志，说是我源站的问题，于是我试着把域名直接解析到源站，而不是解析到CDN，结果是可以正常访问，客服让我刷新CDN缓存，然后我刷新了静态文件所在的两个目录（是递归刷新的），但是问题依旧，客服也头疼了。然后客服又对比了我的源站首页文件的md5和存在于CDN节点里面的我的网站首页文件的md5，说这两个文件不一样，而恰好我的首页是index.php，并不在静态文件目录中，所以没有被我刷新。所以客服最终给的答案是刷新整个网站根目录的所有文件（递归刷新），即**https://www.example.com/**中所有的文件，还真有效！！！\n首页显示的文章浏览量不更新 # 这个问题出现的原因是php存在CDN节点中，只有第一次访问的时候它被执行了，所以后面就没法动态更新了。解决的办法是看看你的博客软件有没有提供相关的动态更新功能，或者相关的插件。像我使用的zblog就没有这种功能和插件，所以只能自己用ajax折腾了，我现在还在熟悉zblog的文件结构，折腾可能还需要一段时间，等我折腾好我会更新这篇文章\u0026hellip;\u0026hellip;\n\u0026mdash;\u0026mdash;2022-11-17\u0026mdash;\u0026mdash;\n学了云计算，更正一个错误：响应头中出现多个x-cache-lookup，并不是因为递归解析，DNS无法携带那些东西(这也是为什么现在的CDN调度算法依然无法做到边缘调度，就近分发的原因)。现在我依然没有搞清楚原因，个人猜测如下：\n因为访问网站的时候，对于动态文件，CDN节点没有做缓存，这时就cache miss，于是CDN节点回源，获取源站渲染的页面，缓存到节点，这时浏览器再次获取，就HIT了\n","date":"2022年04月27日","externalUrl":null,"permalink":"/tutorial/2022/04/tutorial-cdn-service/","section":"Tutorials","summary":"最近给我的个人网站开通了CDN服务，折腾了好久才算是“可以用了”，虽然还有一些小小的问题，但好在不是那么地影响使用。","title":"个人网站接入CDN","type":"tutorial"},{"content":"","date":"2022年04月27日","externalUrl":null,"permalink":"/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1/","section":"Categories","summary":"","title":"云服务","type":"categories"},{"content":"","date":"2022年04月27日","externalUrl":null,"permalink":"/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/","section":"Tags","summary":"","title":"云服务","type":"tags"},{"content":"","date":"2022年04月04日","externalUrl":null,"permalink":"/tags/centos/","section":"Tags","summary":"","title":"CentOS","type":"tags"},{"content":"[网站迁移，排版错乱敬请原谅]\n一开始，我以为安装openGauss也就跟手动安装MySQL差不多，但是当我开始动手没多久我就知道我要踩很多坑了，openGauss的社区还非常地渺小，所以即使是我这一篇不起眼的文章，也许都能帮到不少人，所以决定记录下来。\n极简版的安装比较简单，我在这里就不多说了，首先是因为我一开始没有看清楚老师的要求，安装了极简版，已经大功告成了才发现不对劲，没有gs_om命令！所以我觉得应该不难安装。其次是因为**企业版包含了极简版的所有功能**，所以安装企业版即可。\n老师给了安装的指导书，我后面会把主要内容放在后面，但其实我好多东西都没有按照指导书来，因为我一开始就与指导书有了很大的“分歧”。\n以下是我的安装踩坑填坑过程：\n主要讲我踩坑的部分，大家可以参照后面的文档安装，遇到坑再来看我的教程。\n以下步骤若没有特别说明，均是在root用户下进行操作。\n## 1.下载安装 安装包从官网下载即可：软件包 | openGauss 2.1.0\n（1）下载到当前文件夹： # wget [下载链接] （2）解压到当前文件夹： # tar -zxvf fileName（扩展名也要带上） 解压之后会得到更多的压缩文件：\n（3）老师要求安装的是最上面的文件，om应该是代表单机安装的意思（one machine？？？没求证过）。所以就直接解压这个文件就好了，解压方式同上一步 # （4）解压之后是这样的：（下图第一个文件是没有的，需要自己创建，文件内的内容下面文档有说） # 编写clusterconfig.xml文件，这一步按部就班即可。 # ### （5）执行集群配置脚本 python gs_preinstall -U omm -G dbgrp -X /opt/software/openGauss/clusterconfig.xml 然后前方高能了，开始出现各种错误了。\n这个命令啥意思呢？一定要读懂命令的意思。python是使用python执行python脚本的命令，gs_preinstall是openGauss提供的一个前置安装脚本，-U omm是创建用户omm，-G dbgrp是为用户omm指定用户组dbgrp，-X是指定配置文件路径，后面的一串就是路径。\n2.解决问题 （1）我遇到的第一个问题是系统版本问题，因为我电脑上的虚拟机是很久之前就已经安装了的，是CentOS7.9，在openGauss安装完毕之后显示不支持这个系统版本，需要降级到CentOS7.6。这里注意，不是跨大版本降级，只需要使用rpm包即可。 # 1）获取降级包： # wget https://www.repo.cloudlinux.com/cloudlinux/migrate/release-files/centos/7/x86\u0026lt;em\u0026gt;64/centos-release-7-6.1810.2.el7.centos.x86\u0026lt;/em\u0026gt;64.rpm 2）强制安装： # rpm -ivh centos-release-7-6.1810.2.el7.centos.x86_64.rpm --force --nodeps 注意：force是灵魂，没有force会安装不上，因为会与原版本冲突。\n3）查看release： # rpm -qa |grep -i centos-release 4）移除较新版本的release，降级成功 # rpm -ev ******（就是上面查出来那个新版的信息） （2）第二个问题是python不可用，具体就是执行脚本的时候显示python：command not found（未找到命令）。原因可能有两个，第一就是系统找不到python在哪儿，第二就是没安装python。 # 没安装python的可能性很小，CentOS是自带python的，除非你自己闲着没事去删了，那只能重装了（下面会说）。如果是系统找不到，那你就先自己找到，然后建立软连接就可以了。\n#### 1）找到python安装目录： whereis python 注意：像这种文件夹才是正儿八经的python目录，单个文件的不是，因为python的安装包原本就是个压缩包，解压出来就是个文件夹。\n在命令行中区分文件和文件夹的方法：\n在想查看的目录下执行以下命令：\nls -l 显示的结果中，最左边一列的第一个字母是d就是文件夹（directory）\n或者在SSH工具Xshell中，文件夹会以蓝色字体显示：\n2）创建软连接： # ln -s 所查到的python目录 /usr/bin/python 好像 ln -s 所查到的python目录 /usr/bin 也可以 3）检查是否成功： # python -V（V是大写的） 显示python版本号说明成功了。\n### （3）官方脚本中存在使用python3命令执行的脚本，如果系统中没有安装python3，就会导致执行安装脚本到一半时出现报错 -bash: python3: command not found # 办法就是升级python3了。 1）安装依赖： # \u0026lt;pre class=\u0026#34;prism-highlight prism-language-bash\u0026#34;\u0026gt;yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel 2）获取python安装包： # wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz 3）解压： # tar -zxvf Python-3.6.8.tar.xz 4）创建编译安装文件夹： # mkdir 你想安装的路径和文件夹名称 5）进入解压出来的python文件夹： # cd Python-3.6.8所在的目录 6）依赖检查、指定安装目录： # ./configure --prefix=\u0026#34;第四步中创建的编译安装文件夹的绝对路径\u0026#34; 7）开始编译安装： # make \u0026amp;\u0026amp; make install 8）创建软连接：（参见第二个问题） # ln -s python目录 /usr/bin/python3 注意：是/usr/bin/python3。\n### （4）安装python3后yum不可用 原因是yum依赖于python2，把yum的python版本换成Python2就行。\nvim /usr/bin/yum 按i输入，把第一行最后面的python改成python2.7（或原先的python2.x），按ESC结束编辑，输入: w q三个字符、回车退出vim编辑器。\n（5）python3安装不成功，第四个问题中第（6）步执行 # ./configure --prefix=\u0026#34;第四步中创建的编译安装文件夹的绝对路径\u0026#34; 的时候出现依赖检查失败。 # 提示是类似于no working C compiler\n我出现这个问题是因为没有安装gcc，因为python3的编译安装是用gcc来编译的。\n但是安装gcc时也可能会报错：\nError installing GMP on cygwin \u0026ldquo;configure: error: could not find a working compiler, see config.log for details\u0026rdquo; # 这是GMP安装出错，但我也没找出具体原因，我过了一段时间又去Google了一下解决办法，然后用一位CSDN哥们给的命令成功安装了。CentOS 7安装gcc,并编辑运行第一个c/c++程序（含vi编辑器的简单使用）\nyum -y install gcc gcc-c++ kernel-devel 我不知道是不是不同命令导致的，我就把我成功的命令放这儿吧。\n到这里，整个安装脚本应该可以正常执行了！\n当你满心欢喜，输入openGauss的密码，准备完成安装时，发现又出错了，别急，可能是clusterconfig.xml配置文件的问题。\n### （6）主机名设置不对。 输入hostname可以查看主机名。但是我在腾讯云服务器上面遇到过一个现象，输入hostname显示的是“localhost.localdomain”，但是命令行中显示的却只是“localhost”，配置文件中正确的填法是“localhost.localdomain”，老师给的文档可能有点bug。\n### （7）openGauss启动失败，如下图： 很遗憾，这个情况我目前也没有解决，大家遇到这个问题也就自求多福吧。可能是虚拟机的内存和CPU核心数设置得太低了，大家可以试着调高一点，但不确保可以解决问题。或者有其他懂哥的话可以分享一下解决方案。\n### （8）以gs_开头的命令不可用，显示-bash:command not found 这个可以设置环境变量解决，也可以设置软连接解决。\n在root用户下，设置软连接即可：\nln -s gs_开头的文件的路径 /usr/bin 非root用户（omm）下无法访问/usr/bin，所以不能设置软连接，但是在该用户下执行的gs相关的bash并不多，直接cd到gs命令所在的目录去执行gs_命令即可。\n### （9）执行安装命令gs_install时出错 执行后显示错误：\ncreatedb: too many command line arguments (first is \u0026ndash; encoding=UTF8)\n（太多命令行参数（第一个是 \u0026ndash; encoding=UTF8））\n我没有想太多，它嫌太多参数我就直接把它（\u0026ndash; encoding=UTF8）删了，所以上面绿色的命令就变成了：\ngs_install -X /opt/software/openGauss/clusterconfig.xml --gsinit-parameter=\u0026#34;\u0026#34; --dn-guc=\u0026#34;max_process_memory=4GB\u0026#34; --dnguc=\u0026#34;shared_buffers=128MB\u0026#34; --dn-guc=\u0026#34;bulk_write_ring_size=128MB\u0026#34; -- dn-guc=\u0026#34;cstore_buffers=16MB\u0026#34; 我到这里就可以安装成功了。 （10）可能有的同学在连接数据库的时候，也就是执行以下命令的时候出错： # gsql -d postgres -p 26000 -r 可能是26000端口没有打开，可以自行百度如何打开端口。不过这个问题如果按照指导书安装的话应该不会有，因为指导书是关闭防火墙，直接全开放了。不过在实际开发中这显然属于花式作死\u0026hellip;\u0026hellip;\nCentOS安装openGauss.pdf\n华为 openGauss (GaussDB) 1.0 使用手册\n墨天轮 | openGauss\n","date":"2022年04月04日","externalUrl":null,"permalink":"/tutorial/2022/04/tutorial-opengauss-install/","section":"Tutorials","summary":"openGauss的社区还非常地渺小，所以即使是我这一篇不起眼的文章，也许都能帮到不少人，所以决定记录下来。","title":"CentOS安装openGauss踩坑及填坑教程","type":"tutorial"},{"content":"","date":"2022年04月04日","externalUrl":null,"permalink":"/tags/opengauss/","section":"Tags","summary":"","title":"OpenGauss","type":"tags"},{"content":"","date":"2022年04月04日","externalUrl":null,"permalink":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/","section":"Categories","summary":"","title":"数据库","type":"categories"},{"content":"","date":"2022年04月04日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/","section":"Tags","summary":"","title":"数据库","type":"tags"},{"content":"","date":"2022年03月28日","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"GitHub","type":"tags"},{"content":"如图，GitHub密码忘记，重置时无论用什么浏览器都显示Unable to verify your captcha response。其实我19天前遇到过同样的问题，但是忘记记录了，今天无论怎样都要记录一下。\n找了网上很多办法，多是修改这个修改那个的，我觉得这事儿应该没那个难，于是我用手机试着登录了一下GitHub，然后发现了这个\n微信图片_20220328224625.jpg 哈哈，不知道为什么，可能是这个验证码图片依赖Adobe Flash Player，而电脑浏览器基本都已经没有这个了，但是手机浏览器好像也没有啊，但是手机就能加载出验证码，奇了怪了。电脑因为没加载出验证码，你压根没验证，它当然不给你通过验证，所以可以换用手机试试。\n","date":"2022年03月28日","externalUrl":null,"permalink":"/tutorial/2022/03/tutorial-github-reset-pwd/","section":"Tutorials","summary":"如图，GitHub密码忘记，重置时无论用什么浏览器都显示Unable to verify your captcha response。其实我19天前遇到过同样的问题，但是忘记记录了，今天无论怎样都要记录一下。\n","title":"GitHub重置密码出现Unable to verify your captcha response解决办法","type":"tutorial"},{"content":"","date":"2022年03月28日","externalUrl":null,"permalink":"/categories/%E5%85%B6%E5%AE%83/","section":"Categories","summary":"","title":"其它","type":"categories"},{"content":"","date":"2022年03月18日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"你好，来访的技术爱好者，我是一个全栈工程师，欢迎来到这个小小的技术分享网站，这里没有一蹴而就的巨大成就，只有我日积月累的小小记录。 无论你遇到什么困难，请记住，打不倒你的终将使你更加强大，慢慢来，问题总能解决的，我将给你力所能及的帮助。 除了技术分享，我也会在这里分享一些随笔、日记等，如果对你有帮助，请记得常来！\n","date":"2022年03月18日","externalUrl":null,"permalink":"/about/","section":"Limou's Site","summary":"你好，来访的技术爱好者，我是一个全栈工程师，欢迎来到这个小小的技术分享网站，这里没有一蹴而就的巨大成就，只有我日积月累的小小记录。 无论你遇到什么困难，请记住，打不倒你的终将使你更加强大，慢慢来，问题总能解决的，我将给你力所能及的帮助。 除了技术分享，我也会在这里分享一些随笔、日记等，如果对你有帮助，请记得常来！\n","title":"关于","type":"page"},{"content":"","date":"2022年03月18日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Tags","summary":"","title":"数据结构","type":"tags"},{"content":"这是我的结课总结，认识或许还有很多不足（自己也能感觉到自己的菜），仅供参考，请勿抄袭，谢绝转载，谢谢！ 如有不懂，可发友善留言讨论。\n目录\n一、 图的定义极其相关基本概念 1.1 图的定义 1.2 图的相关概念 1.3 图的抽象数据类型 二、 图的存储 2.1 图的邻接矩阵存储 2.1.1 无向图的邻接矩阵表示 2.1.2 有向图的邻接矩阵表示 2.1.3 函数解析 2.2 图的邻接表存储 2.2.1 无向图的邻接表表示 2.2.2 有向图的邻接表表示 2.2.3函数解析 2.3 图的度 2.3.2 邻接表求度数 2.4 两种存储方式的比较 2.5 带权图 三、 图的遍历 3.1 广度优先遍历 3.1.1 算法分析与方法选择 广度优先遍历过程图示图示 3.2 深度优先遍历 3.2.1 算法分析与方法选择 3.2.2 递归法 3.2.3 非递归法（栈法） 四、 拓扑排序 4.1 算法分析 4.2 应用 五、 最小生成树 一、图的定义极其相关基本概念\n1.1 图的定义\n图是表示物件与物件之间关系的数学对象。\n1.2 图的相关概念\n表示方法：二元组或三元组。其中二元组常用，即用“顶点”集合和“边”集合表示。\n图的分类：有向图和无向图。\n度：与顶点V相关联的边的条数。对于无向图，可分为入度和出度，以顶点V为起点的边的条数即为V的出度，以顶点V为终点的边的条数即为V的入度。\n图的存储：常用的有邻接矩阵存储、邻接表存储。\n图的遍历：深度优先遍历（DFS）和广度优先遍历（BFS）。\n重要概念：最小生成树，拓扑排序。\n1.3 图的抽象数据类型\nADT Graph is\noperations\n创建一个空图\nGraph createGraph(void)\n判断图g是否为空，是则返回1，否则返回0\nInt isNullGraph(Graph g)\n找图中的第一个顶点\nVertex firstVertex(Graph g)\n找图中顶点vi的下一个顶点Vertex nextVertex(Graph g,Vertex vi)\n在图中查找顶点\nVertex searchVertex(Graph g,Vertex vi)\n在图g中增加一个顶点\nGraph addVertex(Graph g,Vertex vi)\n在图g中删除一个顶点和与该点相关联的所有边\nGraph deleteVertex(Graph g,Vertex v)\n在图g中删除一条边e(\u0026lt;vi,vj\u0026gt;或者(vi,vj))\nGraph deleteEdge(Graph g,Vertex vi,Vertex vj)\n在图g中增加一条边\u0026lt;vi,vj\u0026gt;或者(vi,vj)\nGraph addEdge(Graph g,Vertex vi,Vertex vj)\n判断图g中是否存在一条指定边\u0026lt;vi,vj\u0026gt;或者(vi,vj)\nint findEdge(Graph g,Vertex vi,Vertex vj)\n找图g中与顶点v相邻的第一个顶点\nVertex firstAdjacent(Graph g,Vertex v)\n/v与返回顶点构成的边也称为与v相关联的第一条边/\n找图g中与顶点vi相邻的，相对相邻顶点vj的，下一个相邻顶点\nVertex nextAdjacent(Graph g,Vertex vi,Vertex vj)\n/vi与返回顶点构成的边也称为是vi与vj构成的边的下一条边/\n二、图的存储\n2.1 图的邻接矩阵存储\n2.1.1 无向图的邻接矩阵表示\n数学表示\n无向图就是边没有方向的图，对于图G(V,E),V={v1,v2,v3,\u0026hellip;,vn}是图G的顶点集，E={e1,e2,e3,\u0026hellip;,en}是图G的边集。无向图的每一条边都可以用一个无序对表示，且为圆括号，如e =（vi,vj）表示顶点(vi,vj)之间的边。边(vi,vj)和边(vj,vi)表示同一条边。\n邻接矩阵是用一个二维矩阵存储图中各个顶点和边的信息的存储方式，它是完全使用顺序存储方式的。在邻接矩阵中，存储的是顶点和顶点之间的相邻关系。对于无权图，用1表示相邻，0表示不相邻。\n如图所示为一个矩阵（矩阵1），若该矩阵为图G的邻接矩阵（编号从1开始），则矩阵中的a(ij)存储的是顶点v(i)到v(j)之间的边，即边(vi,vj)（或边(vj,vi)）的信息。\n矩阵1\n对于无向图，由于前文提到的边(vi,vj)和边(vj,vi)是同一条边，故矩阵中a(ij)=a(ji)，从而可以得到如下矩阵（矩阵2）。\n图片2.png 矩阵2\n从矩阵中可以看到无向图的邻接矩阵是关于主对角线对称的。\n数据结构表示\n前文提到，邻接矩阵的存储是完全地采用顺序存储方式进行存储的。即二维数组实质上是一段连续的存储空间。\n1. typedef struct {\n2. int vcount;\n3. int type;\n4. char vexs[N];\n5. int arcs[N][N];\n6. } GraphMatrix;\n代码块1\n上述代码（代码块1）为邻接矩阵的数据结构C语言代码。其中共有4个成员变量，vcount是记录图中顶点个数的整型变量；type用于指定图的类型，有向图用0表示，无向图用1表示；vex[N]是图中顶点的信息；arcs是存储图中边信息的整型二维数组，arcs[i][j]表示vex[i]和vex[j]之间的边。\n2.1.2 有向图的邻接矩阵表示\n有向图的邻接矩阵表示和无向图基本相同，仅存在以下几个不同：\n（1）有向图的“边”称为“弧”；\n（2）有向图中弧的数学表示方法为有序对，且为尖括号表示，如\u0026lt;vi,vj\u0026gt;表示顶点 vi到顶点vj的有向弧；\n（3）如下矩阵，有向图中，邻接矩阵中的a(ij)与a(ji)不一定相等，即其邻接矩阵不一定是对称矩阵。\n图片3.png 矩阵3\n（4）有向图邻接矩阵中的a(ij)表示以vi为起点，vj为终点的边；\n（5）有向图进行邻接矩阵存储时，仅对于输入的边（vi,vj），仅将二维数组vex 中的arcs[i][j]置为1；\n有向图的数据结构和无向图完全一致。\n2.1.3 函数解析\n邻接矩阵的基本操作比较简单，主要有邻接矩阵的初始化、点集的输入和边信息的输入。\n(1) GraphMatrix *initGraphMatrix();\n函数功能：初始化邻接矩阵，并完成边集的输入（不输入顶点信息）。\n输入：图的类型、顶点数、边数；边的起始、终点顶点编号。\n返回值：初始化完成并完成顶点集和边集存储的邻接矩阵。\n主要思路：把图的类型和顶点数、边数输入完成后，首先使用双重循环将邻接矩阵中的每个元素置为0，再输入所有的边，每条边用former表示一端的下标，latter表示另一端的下标。对于无向图（type=0）,将邻接矩阵中的第former行第latter列的元素(arcs[former][latter])和第former行第latter列的元素(arcs[latter][former])置为1。对于有向图（type=1），则仅将邻接矩阵中的第former行第latter列的元素(arcs[former][latter])置为1。\n2.2 图的邻接表存储\n2.2.1 无向图的邻接表表示\n数学表示\n邻接表是用顺序表和链表混合存储图信息的存储方式，其存储方法与哈希表存储方法中的拉链法类似，即使用一个顺序表保存顶点信息和一个指针域，该指针域指向一个链表，该链表为与该顶点邻接的顶点的链表。邻接表的结构如下图所示,图2是图1所示无向图的邻接表。\n图片4.png 图 1 无向图\n202203181647605093463291.png 图 2 无向图的邻接表\n由图可以看到，在邻接表中，大体上可以分为两个部分，即左边的顺序表和右边的链表，左边的顺序表用于存储顶点以及顶点的信息；右边的链表用于存储图中边的信息，称为边表。每一个顶点都带有一个边表。与某顶点v邻接的所有顶点都存储在v的边表中。同时，在顺序表中，顶点v除了存储顶点信息的数据域，还带有一个指针域，该指针指向v的边表的第一个元素。如图2中的邻接表中，0号顶点的数据域存有数据v0，指针域存有指针P0，该指针指向0号顶点的边表，该边表中存储了与0号顶点相邻的所有顶点的编号，即1号、2号和3号顶点。\n数据结构表示\n前文提到，邻接表是使用顺序表和链表混合存储图的数据结构。\n1. typedef struct { 2. char vertex;\n3. int degree;\n4. EdgeList edgelist;\n5. } VexNode; 代码块2\n1. typedef struct { 2. VexNode vexs[N];\n3. int type;\n4. int vcount;\n5. } GraphList; 代码块3\n上述代码为邻接表的数据结构C语言代码，代码块2中共包含3个成员变量，代码块3中也有3个成员变量。代码块3中的vex[N]是用于存储顶点信息和该顶点对应的边表指针的顺序表，即图的顶点表，type是图的类型，vcount是图中顶点的个数。代码块2是每个顶点的数据结构，vertex是顶点的信息，degree是顶点的度，edgelist是顶点的边表指针。可以看出，顶点表是一个顺序表，而边表是一个链表。\n2.2.2 有向图的邻接表表示\n有向图的邻接表分为两种，即出边表和入边表。出边表即把所有以某顶点v为起点的弧的终点存储到v的边表中，入边表即把所有以某顶点v为终点的弧的起点存储到v的边表中。如下图，图4是图3中有向图的出边表，而图5是该有向图的入边表。其数据结构与的设计无向图完全一致。\n图片6.png 图 3 有向图\n图片7.png 图 4 有向图的出边表\n图片8.png 图 5 有向图的入边表\n2.2.3函数解析\n（1）GraphList *initGraphList();\n函数功能：初始化邻接表，并完成顶点和边信息的输入和保存。\n输入：图的类型、图的顶点数和边数；顶点信息；边的起始和终止顶点编号，以及该边的权值。\n返回值：初始化好，并且已经完成顶点和边输入极其存储的邻接表GL。\n主要思路：\n（1）初始化：创建一个邻接表对象，接收完图类型、顶点和边数输入后，将邻接表中每个顶点的入度初始化为0；\n（2）构建邻接表：①输入点集并保存在顶点表中；\n②为每一个顶点申请一个边表存储空间；\n③输入边信息，用三个变量former、latter和weight分别存储边的起点下标、终点下标和权值；\n④根据输入的边的起点、终点把顶点v的邻接顶点插入到v的边表的头部。对于无向图，需要在下标为former的顶点的边表中插入latter，还要在下标为latter的顶点的边表中插入former。同时还要在边表的相应结点中存储v到该结点的边的权值。在边表结点中还要设置一个指针域用于指向下一个邻接顶点。对于有向图，则不需要在下标为latter的顶点的边表中插入former,其余与无向图一致。\n2.3 图的度\n数学表示\n与顶点V相关联的边的条数。对于无向图，可分为入度和出度，以顶点V为起点的边的条数即为V的出度，以顶点V为终点的边的条数即为V的入度。\n2.3.1 邻接矩阵求度数\n图片9.png 矩阵4\n如上矩阵（矩阵4）是图1无向图的邻接矩阵，由于邻接矩阵中的1表示某顶点vi与vj邻接，所以上述矩阵中的第i行（或第j列）的1的个数即为下标为i（或j）的顶点的度数。\n图片10.png 矩阵5\n如上矩阵（矩阵5）是图3有向图的邻接矩阵，由于邻接矩阵中的1表示图中存在某顶点vi到vj的有向边，所以上述矩阵中的第i行的1的个数即为下标为i的顶点的出度，第j列的1的个数即为下标为j的顶点的入度。\n算法\n1. int vexs[N][N]; 2. for (int i = 0; i \u0026lt; vexs.length; i++) { 3. int degree = 0; 4. for (int j = 0; j \u0026lt; vexs.length; j++) { 5. if (vexs[i][j]==1){ 6. degree++; 7. } 8. } 9. printf(\u0026quot;%d\\n\u0026quot;,degree); 10. } 代码块4 无向图矩阵求度数\n1. int vexs[N][N]; 2. for (int i = 0; i \u0026lt; vexs.length; i++) { 3. int inCount = 0; 4. int outCount = 0; 5. for (int j = 0; j \u0026lt; vexs.length; j++) { 6. if (vexs[j][i]!=0\u0026amp;\u0026amp;i!=j){ 7. inCount++; 8. } 9. if (vexs[i][j]!=0\u0026amp;\u0026amp;i!=j){ 10. outCount++; 11. } 12. } 13. printf(\u0026quot;%d %d\u0026quot;,inCount,outCount); 14. } 代码块5 有向图矩阵求度数\n2.3.2 邻接表求度数\n邻接表求度数比较简单，如图2无向图的邻接表中，求顶点vi的度数，只需查找vi的边表中顶点的个数即可。而对于图3有向图，要求顶点出度则到如图4的出边表中查找相应顶点的边表中顶点个数即可，要求顶点入度则到图5的入边表中查找相应顶点的边表中顶点个数即可。\n算法\n1. void function(GraphList GL) { 2. VexNode vexs[] = GL-\u0026gt;vexs; 3. for (int i = 0; i \u0026lt; vexs.length; i++) { 4. int degree = 0; 5. EdgeList EL = GL-\u0026gt;vexs[i].edgelist; 6. while (EL!=NULL){ 7. degree++; 8. EL = EL-\u0026gt;nextedge; 9. } 10. printf(\u0026quot;%d\\n\u0026quot;,degree); 11. } 12. } 代码块6 邻接表求度数\n2.4 两种存储方式的比较\n邻接矩阵和邻接表各有优缺点，分别适合不同的场景。\n优点缺点适用场景邻接矩阵①快速确定两点之间是否有边；②快速添加、删除边在存储稀疏图时浪费的空间较多稠密图（边数e\u003enlog(2)n）邻接表节省空间，之存储存在的边求顶点的度时，需要遍历整个链表稀疏图（边数e 表 1 两种存储方式的比较\n2.5 带权图\n图中每条边赋予相应权值的图称为带权图（赋权图）。\n若图用邻接矩阵存储，则直接将矩阵中的1改为相应边上的权值即可；若用邻接表存储，则在边表的相应邻接结点上存储相应权值即可。对于无向图，(vi,vj)的权值和(vj,vi)的权值相同。\n三、图的遍历\n3.1 广度优先遍历\n3.1.1 算法分析与方法选择\n广度优先遍历是遍历图中的顶点时，优先遍历某顶点的所有邻接顶点的算法。如图1中从顶点v0开始的广度优先遍历结果为（v0,v1,v3,v2），从v1开始的广度优先遍历结果为（v1,v0,v2,v3）。可见，广度优先遍历遇到顶点时，总是会先把当前顶点和它邻接的所有顶点遍历完，再跳到它所遍历的第一个邻接顶点上，重复上述操作。这种方式的特点和队列的特点类似。所以可以考虑使用队列来完成遍历。如图，右边的是队列，上面是队头，下面是队尾。\n广度优先遍历过程图示图示\n图片11.png 图 6\n图片12.png 图 7\n图片13.png 图 8\n图片14.png 图 9\n图片15.png 图 10\n算法\n1. int *visited = makeFlag(G-\u0026gt;vcount); 2. int v = 0; 3. int Q[20];//顺序队列 4. int front, rear; 5. front = rear = -1; 6. struct EdgeNode *p; 7. printf(\u0026quot;%c \u0026ldquo;, G-\u0026gt;vexs[0].vertex); 8. visited[v] = 1; 9. Q[rear++] = v;//已访问结点入队 10. int t; 11. while (front != rear) { 12. v = Q[front++];//结点出队 13. p = G-\u0026gt;vexs[v].edgelist; 14. while (p) { 15. t = p-\u0026gt;endvex; 16. if (visited[t] == 0) { 17. printf(\u0026quot;%c \u0026ldquo;, G-\u0026gt;vexs[t].vertex); 18. visited[t] = 1; 19. Q[rear++] = t;//已访问结点入队 20. } 21. p = p-\u0026gt;nextedge; 22. } 23. } 24. } 代码块7\n3.2 深度优先遍历\n3.2.1 算法分析与方法选择\n深度优先遍历是在遍历图中的顶点时，优先持续向下遍历直到下一个为空的算法。\n如下图，从v0开始的深度优先遍历结果为(v0,v1,v3,v2,v4)，从v1开始的深度优先遍历结果为（v1,v3,v2,v4,v0）。可见，深度优先遍历在遍历图中的顶点时，总是先持续向下遍历，直到下一个为空时，再一步步回头遍历前面遍历过的顶点的邻接顶点。这个特点和栈的特点很相似，所以可以考虑使用栈或者递归来完成遍历。\n图片16.png 图 11\n深度优先遍历过程图示图示\n图片17.png 图 12\n图片18.png 图 13\n图片19.png 图 14\n图片20.png 图 15\n图片21.png 图 16\n图片22.png 图 17\n3.2.2 递归法\n算法主要代码\n1. void DFS(GraphList G, int i, int visited) { 2. visited[i] = 1; 3. printf(\u0026quot;%c \u0026ldquo;, G-\u0026gt;vexs[i].vertex); 4. 5. struct EdgeNode *p = G-\u0026gt;vexs[i].edgelist; 6. while (p) { 7. if (!visited[p-\u0026gt;endvex]) { 8. DFS(G, p-\u0026gt;endvex, visited); //递归深度遍历 9. } 10. p = p-\u0026gt;nextedge; 11. } 12. } 1. void DFS_list(GraphList *G) { 2. int *visited = makeFlag(G-\u0026gt;vcount); 3. int i; 4. for (i = 0; i \u0026lt; G-\u0026gt;vcount; i++) { 5. visited[i] = 0; 6. } 7. for (i = 0; i \u0026lt; G-\u0026gt;vcount; i++) { 8. if (visited[i] != 1) { 9. DFS(G, i, visited); 10. } 11. } 12. 13. } 3.2.3 非递归法（栈法）\n1. void DFS_list(GraphList *G) { 2. //非递归法（栈），卒！ 3. int Stack[20]; 4. int top = -1; 5. struct EdgeNode *p; 6. int v = 0; 7. int *visited = makeFlag(G-\u0026gt;vcount); 8. int t; 9. printf(\u0026quot;%c \u0026ldquo;,G-\u0026gt;vexs[0].vertex); 10. visited[v] = 1; 11. Stack[top+1] = v; 12. top++; 13. while (top!=-1){ 14. v = Stack[top]; 15. p = G-\u0026gt;vexs[v].edgelist; 16. while (p){ 17. printf(\u0026ldquo;while\u0026rdquo;); 18. t = p-\u0026gt;endvex; 19. if (visited[t]==0){ 20. printf(\u0026ldquo;66 \u0026ldquo;); 21. 22. printf(\u0026quot;%c \u0026ldquo;,G-\u0026gt;vexs[t].vertex); 23. printf(\u0026ldquo;77 \u0026ldquo;); 24. visited[t] = 1; 25. printf(\u0026ldquo;88 \u0026ldquo;); 26. Stack[top++] = t;//已访问结点入栈 27. printf(\u0026rdquo;[%d %d] \u0026ldquo;,top,t); 28. } 29. p = p-\u0026gt;nextedge; 30. } 31. } 32. } 四、拓扑排序\n4.1 算法分析\n拓扑排序是一个有向无环图的所有顶点的线性序列，每个顶点再序列中仅出现一次，且如果序列中存在顶点v0到v1的路径，那么在序列中v0必定出现在v1之前。\n拓扑排序的算法思想如下：\n1. 在一个有向图中，选择一个入度为0的顶点，将该顶点输出；\n2. 从图中删除该顶点以及所有以该顶点为起点的有向边。\n3. 重复1和2，直到输出完所有顶点为止。\n图片23.png 图 18\n如图18所示，该图的拓扑排序序列为（v1,v2,v4,v3,v5）。\n算法主要代码\n1. void Top_list(GraphList *G) { 2. for (int i = 0; i \u0026lt; G-\u0026gt;vcount; i++) { 3. if (G-\u0026gt;vexs[i].degree == 0) { 4. printf(\u0026quot;%c \u0026ldquo;, G-\u0026gt;vexs[i].vertex); 5. EdgeList EL = G-\u0026gt;vexs[i].edgelist; 6. while (EL != NULL) { 7. G-\u0026gt;vexs[EL-\u0026gt;endvex].degree\u0026ndash;; 8. EL = EL-\u0026gt;nextedge; 9. } 10. } 11. } 12. 13. } 4.2 应用\n拓扑排序常用于解决有依赖关系的复杂任务。比如大学生选修课程的现后顺序，使用拓扑排序就可以得到满足课程依赖关系的选修顺序。又比如工程项目，很多工程项目是需要前面的先完成，后面的才能做的，使用拓扑排序就可以排出正确的施工顺序。\n五、最小生成树\n最小生成树是一个包含原图所有顶点，且边最少的连通图子图。有n个顶点的图的最小生成树中有n-1条边。\n求最小生成树的算法有克鲁斯卡尔算法和普里姆算法，其中普里姆算法较常用。\n算法步骤\n（1）输入：一个加权连通图，其中顶点集合为V，边集合为E；\n（2）初始化：Vnew= {x}，其中x为集合V中的任一节点（起始点），Enew= {},为空；\n（3）重复下列操作，直到Vnew= V：\na.在集合E中选取权值最小的边\u0026lt;u, v\u0026gt;，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；\nb.将v加入集合Vnew中，将\u0026lt;u, v\u0026gt;边加入集合Enew中；\n（4）输出：使用集合Vnew和Enew来描述所得到的最小生成树。\n算法代码\n1. int getWeight(GraphList G, int start, int end) 2. { 3. struct EdgeNode *node; 4. 5. if (start==end) 6. return 0; 7. 8. node = G.vexs[start].edgelist-\u0026gt;nextedge; 9. while (node!=NULL) 10. { 11. if (end==node-\u0026gt;endvex) 12. return node-\u0026gt;weight; 13. node = node-\u0026gt;nextedge; 14. } 15. 16. return 10000; 17. } ","date":"2022年03月18日","externalUrl":null,"permalink":"/posts/2022/03/post-shujujiegou-tulun/","section":"Posts","summary":"数据结构图论章节的一些总结","title":"数据结构-图论","type":"posts"},{"content":"","date":"2022年03月18日","externalUrl":null,"permalink":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","section":"Categories","summary":"","title":"数据结构与算法","type":"categories"},{"content":"","date":"2022年03月18日","externalUrl":null,"permalink":"/tags/%E5%9B%BE%E8%AE%BA/","section":"Tags","summary":"","title":"图论","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]